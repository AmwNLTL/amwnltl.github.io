---
layout: post
title: "Early-Stage Debugging of an Antimalware PPL Service in User Mode"
description: "Have you ever questioned yourself about how to debug an Antimalware PPL Service in User Mode to catch it on initialization ($exentry)?"
date: 2025-08-09
last_modified_at: 2025-08-09
permalink: "early-stage-debugging-of-an-antimalware-ppl-service-in-user-mode"
noindex: false
sitemap: true
tag: [windows-internals, ppl, antimalware, kernel-debugging, windbg]
---

Debugging an Antimalware Service during its initialization in User Mode hmmm.. Have you ever questioned yourself about how to debug an Antimalware PPL Service in User Mode and catch it on initialization (e.g. $exentry)?

## Overview

So here is the general plan what has to be done.

1. Remove PPL from the target process
2. From Kernel Mode Debugging Session, break at process creation to catch process initialization
3. Freeze process by modifying ***KPROCESS*** structure
4. Attach User Mode WinDbg with patience
5. Restore modified kernel flags
6. Continue with normal User Mode debugging

And the thing is that for setting up a UM debugging session we got to have the KM one. I will not describe how to do that, there are plenty guides (I prefer Microsoft one).

## (un|de)PPLing

So the first step will be removing PPL flag from the service process we want to debug. There is a tool called [PPLcontrol](https://github.com/itm4n/PPLcontrol) that, used with RTCore64.sys driver (Vulnerable MSI Driver) mentioned there, allows to remove the PPL flag from the process. 

> Of course, having a KM debugging session we could do that by hands editing kernel structs but there is the tool why we don't use it. Btw not that many vendors blocking the tool from running. 

Copy-paste below is how PPL downgrade is done in one shot:

```txt
C:\Users\user\Desktop>pplcontrol\PPLcontrol.exe
Usage:
  pplcontrol\PPLcontrol.exe <CMD> <ARGS>

Commands:
  list
  get <PID>
  set <PID> <PP|PPL> <TYPE>
  protect <PID> <PP|PPL> <TYPE>
  unprotect <PID>

Signer Types:
  Authenticode, CodeGen, Antimalware, Lsa, Windows, WinTcb, WinSystem

Install the driver:
  sc.exe create RTCore64 type= kernel start= auto binPath= C:\PATH\TO\RTCore64.sys
  net start RTCore64

Uninstall the driver:
  net stop RTCore64
  sc.exe delete RTCore64

C:\Users\user\Desktop>pplcontrol\PPLcontrol.exe get 4220
[+] The process with PID 4220 is a PPL with the Signer type 'Antimalware' (3).

C:\Users\user\Desktop>pplcontrol\PPLcontrol.exe unprotect 4220
[+] The process with PID 4220 is no longer a PP(L).

C:\Users\user\Desktop>pplcontrol\PPLcontrol.exe get 4220
[*] The process with PID 4220 is not protected.
```

## Freezing

When the flag is unset we are ready to kill and catch the process on creation routine but first we have to set a breakpoint in KM debugging session:

```txt
bp nt!PspInsertProcess
```

This breakpoint allows us to catch a process on its creation routine and next send it to **Deep Freeze** as soon as the first thread is up.

So what's is freezing. To be short it is a suspending of the process as simple as it is. Suspending/Resuming is meant to be for threads and Freezing/Thawing - for processes.

After breakpoint is set we can continue target execution and kill the process. There can be kinda many processes be spawned at short period of time so we have to inspect the *@rcx* register for the correct one:

```txt
dt nt!_EPROCESS @rcx
```

And somewhere at offset *+0x5a8* (offset can differ) there is a *ImageFileName* member with the target process.

It is annoying to have plenty of other processes to be spawned by the system, so instead of manual sorting we can set a conditional breakpoint to break right when the needed process is created:
```txt
bp nt!PspInsertProcess "
    .if (@@c++(strcmp((char*)((nt!_EPROCESS*)@rcx)->ImageFileName, \"someedrprocess\")) != 0) { gc } 
    .else { }
"
```
Just keep in mind the fact that the *ImageFileName* member is **only 14 chars long**.

When the routine is hit with the correct process we let it execute with **`gu`** command. Process structure has be initialized before we edit it.

Now we have to prepare the process to be sent in **Deep Freeze**. For that we have to locate *ProcessFlags* in ***KPROCESS*** struct (***EPROCESS*** struct points at ***KPROCESS***). For 23H2 build its offset is 0x278 and it looks like that:

```txt
union
    {
        struct
        {
            ULONG AutoAlignment:1;             //0x278 1
            ULONG DisableBoost:1;              //0x278 2
            ULONG DisableQuantum:1;            //0x278 4
            ULONG DeepFreeze:1;                //0x278 8
            ULONG TimerVirtualization:1;       //0x278
            ULONG CheckStackExtents:1;         //0x278 
            ULONG CacheIsolationEnabled:1;     //0x278
            ULONG PpmPolicy:4;                 //0x278
            ULONG VaSpaceDeleted:1;            //0x278
            ULONG MultiGroup:1;                //0x278
            ULONG ReservedFlags:19;            //0x278
        };
        volatile LONG ProcessFlags;            //0x278
    };
```

> In 24H2 the offest is 0x88 but the *ProcessFlags* itself is the same.

By default if you resolve the address with **`db`** you can see that the flags are set at 0x20, we can't change these (gonna be punished with BSOD) so preserving old bits we have to add ours 0x8.

```txt
// !! offset can differ
// rcx still points at EPROCESS
eb @rcx+0x278 28; r rcx;
```

After that we let it go by removing bps with **`bc *; g;`** and can jump into UM debugging.

BUT if you want to see results of setting the flags you can set a breakpoint right after *PspInsertThread* like shown below:

![Breakpoint after PspInsertThread](/assets/images/psp-insert-thread-bp.png)

After that you can check process info and see ***Deep Freeze*** state:

![Deep Freezed Process](/assets/images/eprocess-deep-freezed.png)

## Back to UM

Firstly, on target machine you have to check if the PPL flag is up (some vendors don't have set it back up after service restarts lol) and unset it again if it is.

Then we can attach with your favourite debugger. I prefer WinDbg and right after attaching it says about **waiting for 30 secs**. We have to wait!

After that we are ready to set breakpoints where we need, e.g. at EntryPoint:
```txt
bp $exentry
```

> For e.g. DLLs deferred can be set and ofc it works just as it should be

After setting bp it is important **not to continue program execution** and unset **Deep Freeze** flag in KM debugging session:
```txt
// !! offset can differ
eb <EPROCESS_from_rcx_before>+0x278 20; g;
```

Then we go back to UM and press **Break** (it is not a typo mistake), it continues exectuion where most DLLs are loaded. Multiple bps can be created on initializion or just because someting not needed dies (because we mess with some things) we just skip them until our target bp is hit.

Then I stringly recommend to **snapshot your target VM** and you are good to go to "debug an Antimalware Service during its initialization".

Thanks for reading!